SET search_path = public,contrib,tap;

BEGIN;
SELECT plan(71);
--SELECT * FROM no_plan();

-- Check that we have the functions we think we have.
SELECT has_function(f)
  FROM unnest(ARRAY[
      'setup_meta', 'get_provided', 'get_meta', 'record_ownership', 'add_distribution'
  ]) AS f;

SELECT has_function('setup_meta', ARRAY['label', 'text', 'text']);
SELECT has_function('get_meta', '{}'::text[]);
SELECT has_function('get_provided', '{}'::text[]);
SELECT has_function('record_ownership', ARRAY['label', 'text[]']);
SELECT has_function('add_distribution', ARRAY['label', 'text', 'text']);

-- User "pgxn" should not have access to most of them.
SELECT ok(
    NOT has_function_privilege('pgxn', f, 'EXECUTE'),
    'User "pgxn" should not have EXECUTE priv on ' || f
) FROM unnest(ARRAY[
    'setup_meta(label, text, text)',
    'get_provided()',
    'get_meta()',
    'record_ownership(label, text[])'
]) AS f;

-- User "pgxn" only has access to add_distribution().
SELECT ok(
    has_function_privilege(
        'pgxn', 'add_distribution(label, text, text)', 'EXECUTE'
    ),
    'User "pgxn" should have EXECUTE priv on add_distribution()'
);

CREATE OR REPLACE FUNCTION json_eq(
    have TEXT,
    want TEXT
) RETURNS BOOLEAN LANGUAGE plperlu AS $$
    my $have = JSON::XS::decode_json shift;
    my $want = JSON::XS::decode_json shift;
    use Data::Dumper;
    local $Data::Dumper::Indent   = 1;
    local $Data::Dumper::Sortkeys = 1;
    return 1 if Dumper($have) eq Dumper($want);
    elog(INFO, Dumper($have));
    elog(INFO, Dumper($want));
    return 0;
$$;

CREATE FUNCTION has_meta() RETURNS BOOLEAN LANGUAGE plperl AS $$
    return $_SHARED{meta} ? 'true' : 'false';
$$;

/****************************************************************************/
-- Test setup_meta(), get_provided(), and get_meta().
SELECT function_returns('setup_meta', 'text[]' );
SELECT function_lang_is('setup_meta', 'plperl' );
SELECT volatility_is(   'setup_meta', 'volatile' );

-- Validate that missing required fields throw an exception.
SELECT throws_like(
    $$ SELECT setup_meta('nobody', 'pshaw', '{"foo": "whatever"}') $$,
    '%Metadata is missing the required "name" key%',
    'Should get error from setup_meta for messing name'
);

SELECT throws_like(
    $$ SELECT setup_meta('nobody', 'pshaw', '{"name": "pair"}') $$,
    '%Metadata is missing the required "version" key%',
    'Should get error from setup_meta for messing version'
);

SELECT throws_like(
    $$ SELECT setup_meta('nobody', 'pshaw', '{"name": "pair", "version": "0.0.1"}') $$,
    '%Metadata is missing the required "license" key%',
    'Should get error from setup_meta for messing license'
);

SELECT throws_like(
    $$ SELECT setup_meta('nobody', 'pshaw', '{"name": "pair", "version": "0.0.1", "license": "postgresql"}') $$,
    '%Metadata is missing the required "maintainer" key%',
    'Should get error from setup_meta for messing maintainer'
);

SELECT throws_like(
    $$ SELECT setup_meta('nobody', 'pshaw', '{"name": "pair", "version": "0.0.1", "license": "postgresql", "maintainer": "theory"}') $$,
    '%Metadata is missing the required "abstract" key%',
    'Should get error from setup_meta for messing abstract'
);

-- Pass everything.
SELECT is(
    setup_meta('nobody', 'pshaw', '{
        "name": "pair",
        "version": "0.0.01",
        "license": "postgresql",
        "maintainer": "theory",
        "abstract": "Ordered pair",
        "description": "An ordered pair for PostgreSQL",
        "tags": ["foo", "bar", "baz"],
        "no_index": null,
        "prereqs": {
          "runtime": {
            "requires": {
              "PostgreSQL": "8.0.0",
              "PostGIS": "1.5.0"
            },
            "recommends": {
              "PostgreSQL": "8.04.0"
            }
          }
        },
        "provides": {
            "pair": { "file": "pair.sql.in", "version": "0.02.02" },
            "trip": { "file": "trip.sql.in", "version": "0.02.01" }
        },
        "release_status": "testing",
        "resources": {
          "homepage": "http://pgxn.org/dist/pair/"
        }
    }'),
    ARRAY[
        'pair', '0.0.1', 'testing', 'Ordered pair',
        'An ordered pair for PostgreSQL'
    ],
    'Should get expected values from setup_meta()'
);

-- Should get expected provides values.
SELECT is(
    get_provided(),
    ARRAY[['pair', '0.2.2'], ['trip', '0.2.1']],
    'Should get expected values from get_provided()'
);    

select ok( has_meta(), 'Should have cached meta');

-- See that we get the metadata back.
SELECT ok( json_eq( get_meta(), $${
    "name":        "pair",
    "version":     "0.0.1",
    "license":     "postgresql",
    "maintainer":  "theory",
    "abstract":    "Ordered pair",
    "description": "An ordered pair for PostgreSQL",
    "tags":        ["foo", "bar", "baz"],
    "no_index":    null,
    "owner":       "nobody",
    "sha1":        "pshaw",
    "prereqs":     {
        "runtime": {
            "requires": {
                "PostgreSQL": "8.0.0",
                "PostGIS":    "1.5.0"
            },
            "recommends": { "PostgreSQL": "8.4.0" }
        }
    },
    "provides":     {
      "pair": {"file": "pair.sql.in", "version": "0.2.2" },
      "trip": {"file": "trip.sql.in", "version": "0.2.1" }
    },
    "release_status": "testing",
    "resources":      { "homepage": "http://pgxn.org/dist/pair/" }
}$$), 'Should have the expected cached metadata with normalized version strings');

select ok( NOT has_meta(), 'Should no longer have cached meta');

-- Make sure that the "provides" and "release_status" get defaults.
SELECT is(
    setup_meta('nobody', 'pshaw', '{"name": "pair", "version": "0.0.1", "license": "postgresql","maintainer": "theory", "abstract": "whatever"}'),
    ARRAY['pair', '0.0.1', 'stable', 'whatever', NULL],
    'Should get expected default release_status from setup_meta()'
);

SELECT is(
    get_provided(),
    ARRAY[['pair', '0.0.1']],
    'Should get default values from get_provided()'
);    

select ok( has_meta(), 'Should have cached meta again');

SELECT ok( json_eq( get_meta(), $${
    "name":        "pair",
    "version":     "0.0.1",
    "license":     "postgresql",
    "maintainer":  "theory",
    "owner":       "nobody",
    "abstract":    "whatever",
    "release_status": "stable",
    "sha1":        "pshaw",
    "provides": { "pair": { "version": "0.0.1" } }
}$$), 'Metadata should have default release status and provides');

select ok( NOT has_meta(), 'Should once again not have cached meta');

/****************************************************************************/
-- Test record_ownership().
SELECT throws_ok(
    $$ SELECT record_ownership('nobody', ARRAY['foo']) $$,
    '23503', -- FK constraint violation 
    NULL,
    'Should get exception from record_ownership() for non-existent user'
);

-- We need a user.
SELECT ok(
    insert_user('theory', 'wet blanket', email := 'theory@pgxn.org'),
    'Insert user "theory"'
);

-- Make sure we have no extensions.
SELECT is(COUNT(*)::int, 0, 'Should start with no extensions') FROM extensions;

-- Create some extensions for this user.
SELECT ok(
    record_ownership('theory', ARRAY['pair']),
    'Create ownership of "pair" for theory'
);

SELECT is(COUNT(*)::int, 1, 'Should now have one extension') FROM extensions;

SELECT row_eq(
    $$ SELECT * FROM extensions $$,
    ROW('pair', 'theory', NOW(), NOW())::extensions,
    'It should be the expected extension'
);

SELECT is(COUNT(*)::int, 0, 'Should have no co-owners') FROM coowners;

-- Now check for the same extension for the same user.
SELECT ok(
    record_ownership('theory', ARRAY['pair']),
    'Theory should still own "pair"'
);

SELECT is(COUNT(*)::int, 1, 'Should still have one extension') FROM extensions;
SELECT is(COUNT(*)::int, 0, 'Should still have no co-owners') FROM coowners;

-- Create another user to mess with.
SELECT ok(
    insert_user('strongrrl', 'wet blanket', email := 'strongrrl@pgxn.org'),
    'Insert user "strongrrl"'
);

SELECT ok(
    NOT record_ownership('strongrrl', ARRAY['pair']),
    'Strongrrl should not own "pair"'
);

SELECT is(COUNT(*)::int, 1, 'Should still have one extension') FROM extensions;
SELECT is(COUNT(*)::int, 0, 'Should still have no co-owners') FROM coowners;

SELECT row_eq(
    $$ SELECT * FROM extensions $$,
    ROW('pair', 'theory', NOW(), NOW())::extensions,
    'Theory should still own it'
);

-- Grant strongrrl co-ownership.
INSERT INTO coowners (extension, nickname) VALUES ('pair', 'strongrrl');

SELECT ok(
    record_ownership('strongrrl', ARRAY['pair']),
    'Strongrrl should now have co-ownership of "pair"'
);

SELECT is(COUNT(*)::int, 1, 'Should still have one extension') FROM extensions;
SELECT is(COUNT(*)::int, 1, 'Should have one co-owner') FROM coowners;

SELECT row_eq(
    $$ SELECT * FROM extensions $$,
    ROW('pair', 'theory', NOW(), NOW())::extensions,
    'Theory should still own it'
);

-- Now have strongrrl register two.
SELECT ok(
    record_ownership('strongrrl', ARRAY['pair', 'triple']),
    'Strongrrl should own "pair" and "triple"'
);

SELECT is(COUNT(*)::int, 2, 'Should now have two extensions') FROM extensions;
SELECT is(COUNT(*)::int, 1, 'Should still have one co-owner') FROM coowners;

SELECT row_eq(
    $$ SELECT * FROM extensions WHERE owner = 'strongrrl' $$,
    ROW('triple', 'strongrrl', NOW(), NOW())::extensions,
    'Strongrrl should now own "triple"'
);

SELECT row_eq(
    $$ SELECT * FROM extensions $$,
    ROW('pair', 'theory', NOW(), NOW())::extensions,
    'But theory should still own "pair"'
);

-- Have theory upload pair and triple.
SELECT ok(
    NOT record_ownership('theory', ARRAY['pair', 'triple']),
    'Theory should not own both "pair" and "triple"'
);

SELECT is(COUNT(*)::int, 2, 'Should still have two extensions') FROM extensions;
SELECT is(COUNT(*)::int, 1, 'Should still have one co-owner') FROM coowners;

SELECT row_eq(
    $$ SELECT * FROM extensions WHERE owner = 'strongrrl' $$,
    ROW('triple', 'strongrrl', NOW(), NOW())::extensions,
    'Strongrrl should still own "triple"'
);

SELECT row_eq(
    $$ SELECT * FROM extensions $$,
    ROW('pair', 'theory', NOW(), NOW())::extensions,
    'And theory should still own "pair"'
);

-- Give theory co-ownership.
INSERT INTO coowners (extension, nickname) VALUES ('triple', 'theory');
SELECT ok(
    record_ownership('theory', ARRAY['pair', 'triple']),
    'Theory should now have ownership of both "pair" and "triple"'
);

SELECT is(COUNT(*)::int, 2, 'Should still have two extensions') FROM extensions;
SELECT is(COUNT(*)::int, 2, 'Should now have two co-owners') FROM coowners;

SELECT row_eq(
    $$ SELECT * FROM extensions WHERE owner = 'strongrrl' $$,
    ROW('triple', 'strongrrl', NOW(), NOW())::extensions,
    'Strongrrl should still own "triple"'
);

SELECT row_eq(
    $$ SELECT * FROM extensions $$,
    ROW('pair', 'theory', NOW(), NOW())::extensions,
    'And theory should still own "pair"'
);

-- Have theory record to other extensions.
SELECT ok(
    record_ownership('theory', ARRAY['foo', 'bar']),
    'Have theory own "foo" and "bar"'
);

SELECT is(COUNT(*)::int, 4, 'Should now have four extensions') FROM extensions;
SELECT is(COUNT(*)::int, 2, 'Should still have two co-owners') FROM coowners;

SELECT is(
    ARRAY(SELECT name FROM extensions WHERE owner = 'theory' ORDER BY name),
    ARRAY['bar', 'foo', 'pair']::citext[],
    'Theory should have ownership of three extensions'
);

/****************************************************************************/
-- Test add_distribution().

SELECT * FROM finish();
ROLLBACK;
