SET search_path = public,contrib,tap;

BEGIN;
SELECT plan(89);
--SELECT * FROM no_plan();

-- Check that we have the functions we think we have.
SELECT has_function(f)
  FROM unnest(ARRAY[
      'setup_meta', 'record_ownership', 'add_distribution'
  ]) AS f;

SELECT has_function('setup_meta', ARRAY['label', 'text', 'text']);
SELECT has_function('record_ownership', ARRAY['label', 'text[]']);
SELECT has_function('add_distribution', ARRAY['label', 'text', 'text']);

-- User "pgxn" should not have access to most of them.
SELECT ok(
    NOT has_function_privilege('pgxn', f, 'EXECUTE'),
    'User "pgxn" should not have EXECUTE priv on ' || f
) FROM unnest(ARRAY[
    'setup_meta(label, text, text)',
    'record_ownership(label, text[])'
]) AS f;

-- User "pgxn" only has access to add_distribution().
SELECT ok(
    has_function_privilege(
        'pgxn', 'add_distribution(label, text, text)', 'EXECUTE'
    ),
    'User "pgxn" should have EXECUTE priv on add_distribution()'
);

/****************************************************************************/
-- Test setup_meta().
SELECT function_returns('setup_meta', 'record' );
SELECT function_lang_is('setup_meta', 'plperl' );
SELECT volatility_is(   'setup_meta', 'immutable' );

-- Validate that missing required fields throw an exception.
SELECT throws_like(
    $$ SELECT setup_meta('nobody', 'pshaw', '{"foo": "whatever"}') $$,
    '%Metadata is missing the required "name" key%',
    'Should get error from setup_meta for messing name'
);

SELECT throws_like(
    $$ SELECT setup_meta('nobody', 'pshaw', '{"name": "pair"}') $$,
    '%Metadata is missing the required "version" key%',
    'Should get error from setup_meta for messing version'
);

SELECT throws_like(
    $$ SELECT setup_meta('nobody', 'pshaw', '{"name": "pair", "version": "0.0.1"}') $$,
    '%Metadata is missing the required "license" key%',
    'Should get error from setup_meta for messing license'
);

SELECT throws_like(
    $$ SELECT setup_meta('nobody', 'pshaw', '{"name": "pair", "version": "0.0.1", "license": "postgresql"}') $$,
    '%Metadata is missing the required "maintainer" key%',
    'Should get error from setup_meta for messing maintainer'
);

SELECT throws_like(
    $$ SELECT setup_meta('nobody', 'pshaw', '{"name": "pair", "version": "0.0.1", "license": "postgresql", "maintainer": "theory"}') $$,
    '%Metadata is missing the required "abstract" key%',
    'Should get error from setup_meta for messing abstract'
);

-- Pass everything.
SELECT results_eq(
    $$ SELECT * FROM setup_meta('nobody', 'pshaw', '{
        "name": "pair",
        "version": "0.0.01",
        "license": "postgresql",
        "maintainer": "theory",
        "abstract": "Ordered pair",
        "description": "An ordered pair for PostgreSQL",
        "tags": ["foo", "bar", "baz"],
        "no_index": null,
        "prereqs": {
          "runtime": {
            "requires": {
              "PostgreSQL": "8.0.0",
              "PostGIS": "1.5.0"
            },
            "recommends": {
              "PostgreSQL": "8.04.0"
            }
          }
        },
        "provides": {
            "pair": { "file": "pair.sql.in", "version": "0.02.02" },
            "trip": { "file": "trip.sql.in", "version": "0.02.01" }
        },
        "release_status": "testing",
        "resources": {
          "homepage": "http://pgxn.org/dist/pair/"
        }
    }') $$,
    $$ VALUES('pair'::citext, '0.0.1'::semver, 'testing'::relstatus, 'Ordered pair',
    'An ordered pair for PostgreSQL',
    ARRAY[['pair', '0.2.2'], ['trip', '0.2.1']],
    ARRAY['foo'::citext, 'bar', 'baz'], '{
   "name": "pair",
   "abstract": "Ordered pair",
   "description": "An ordered pair for PostgreSQL",
   "version": "0.0.1",
   "maintainer": "theory",
   "release_status": "testing",
   "owner": "nobody",
   "sha1": "pshaw",
   "license": "postgresql",
   "prereqs": {
      "runtime": {
         "recommends": {
            "PostgreSQL": "8.4.0"
         },
         "requires": {
            "PostGIS": "1.5.0",
            "PostgreSQL": "8.0.0"
         }
      }
   },
   "provides": {
      "pair": {
         "file": "pair.sql.in",
         "version": "0.2.2"
      },
      "trip": {
         "file": "trip.sql.in",
         "version": "0.2.1"
      }
   },
   "tags": ["foo", "bar", "baz"],
   "resources": {
      "homepage": "http://pgxn.org/dist/pair/"
   }
}
') $$,
    'Should get expected record from setup_meta()'
);

-- Make sure that the "provided", "relstatus", and "tags" columns get defaults.
SELECT results_eq(
    $$ SELECT provided, relstatus, tags
         FROM setup_meta('nobody', 'pshaw', '{"name": "pair", "version": "0.0.1", "license": "postgresql","maintainer": "theory", "abstract": "whatever"}') $$,
    $$ VALUES (ARRAY[['pair', '0.0.1']], 'stable'::relstatus, '{}'::citext[]) $$,
    'Should get expected default provided, release_status, and tags from setup_meta()'
);

/****************************************************************************/
-- Test record_ownership().
SELECT throws_ok(
    $$ SELECT record_ownership('nobody', ARRAY['foo']) $$,
    '23503', -- FK constraint violation 
    NULL,
    'Should get exception from record_ownership() for non-existent user'
);

-- We need a user.
SELECT ok(
    insert_user('theory', 'wet blanket', email := 'theory@pgxn.org'),
    'Insert user "theory"'
);

-- Make sure we have no extensions.
SELECT is(COUNT(*)::int, 0, 'Should start with no extensions') FROM extensions;

-- Create some extensions for this user.
SELECT ok(
    record_ownership('theory', ARRAY['pair']),
    'Create ownership of "pair" for theory'
);

SELECT is(COUNT(*)::int, 1, 'Should now have one extension') FROM extensions;

SELECT row_eq(
    $$ SELECT * FROM extensions $$,
    ROW('pair', 'theory', NOW(), NOW())::extensions,
    'It should be the expected extension'
);

SELECT is(COUNT(*)::int, 0, 'Should have no co-owners') FROM coowners;

-- Now check for the same extension for the same user.
SELECT ok(
    record_ownership('theory', ARRAY['pair']),
    'Theory should still own "pair"'
);

SELECT is(COUNT(*)::int, 1, 'Should still have one extension') FROM extensions;
SELECT is(COUNT(*)::int, 0, 'Should still have no co-owners') FROM coowners;

-- Create another user to mess with.
SELECT ok(
    insert_user('strongrrl', 'wet blanket', email := 'strongrrl@pgxn.org'),
    'Insert user "strongrrl"'
);

SELECT ok(
    NOT record_ownership('strongrrl', ARRAY['pair']),
    'Strongrrl should not own "pair"'
);

SELECT is(COUNT(*)::int, 1, 'Should still have one extension') FROM extensions;
SELECT is(COUNT(*)::int, 0, 'Should still have no co-owners') FROM coowners;

SELECT row_eq(
    $$ SELECT * FROM extensions $$,
    ROW('pair', 'theory', NOW(), NOW())::extensions,
    'Theory should still own it'
);

-- Grant strongrrl co-ownership.
INSERT INTO coowners (extension, nickname) VALUES ('pair', 'strongrrl');

SELECT ok(
    record_ownership('strongrrl', ARRAY['pair']),
    'Strongrrl should now have co-ownership of "pair"'
);

SELECT is(COUNT(*)::int, 1, 'Should still have one extension') FROM extensions;
SELECT is(COUNT(*)::int, 1, 'Should have one co-owner') FROM coowners;

SELECT row_eq(
    $$ SELECT * FROM extensions $$,
    ROW('pair', 'theory', NOW(), NOW())::extensions,
    'Theory should still own it'
);

-- Now have strongrrl register two.
SELECT ok(
    record_ownership('strongrrl', ARRAY['pair', 'triple']),
    'Strongrrl should own "pair" and "triple"'
);

SELECT is(COUNT(*)::int, 2, 'Should now have two extensions') FROM extensions;
SELECT is(COUNT(*)::int, 1, 'Should still have one co-owner') FROM coowners;

SELECT row_eq(
    $$ SELECT * FROM extensions WHERE owner = 'strongrrl' $$,
    ROW('triple', 'strongrrl', NOW(), NOW())::extensions,
    'Strongrrl should now own "triple"'
);

SELECT row_eq(
    $$ SELECT * FROM extensions $$,
    ROW('pair', 'theory', NOW(), NOW())::extensions,
    'But theory should still own "pair"'
);

-- Have theory upload pair and triple.
SELECT ok(
    NOT record_ownership('theory', ARRAY['pair', 'triple']),
    'Theory should not own both "pair" and "triple"'
);

SELECT is(COUNT(*)::int, 2, 'Should still have two extensions') FROM extensions;
SELECT is(COUNT(*)::int, 1, 'Should still have one co-owner') FROM coowners;

SELECT row_eq(
    $$ SELECT * FROM extensions WHERE owner = 'strongrrl' $$,
    ROW('triple', 'strongrrl', NOW(), NOW())::extensions,
    'Strongrrl should still own "triple"'
);

SELECT row_eq(
    $$ SELECT * FROM extensions $$,
    ROW('pair', 'theory', NOW(), NOW())::extensions,
    'And theory should still own "pair"'
);

-- Give theory co-ownership.
INSERT INTO coowners (extension, nickname) VALUES ('triple', 'theory');
SELECT ok(
    record_ownership('theory', ARRAY['pair', 'triple']),
    'Theory should now have ownership of both "pair" and "triple"'
);

SELECT is(COUNT(*)::int, 2, 'Should still have two extensions') FROM extensions;
SELECT is(COUNT(*)::int, 2, 'Should now have two co-owners') FROM coowners;

SELECT row_eq(
    $$ SELECT * FROM extensions WHERE owner = 'strongrrl' $$,
    ROW('triple', 'strongrrl', NOW(), NOW())::extensions,
    'Strongrrl should still own "triple"'
);

SELECT row_eq(
    $$ SELECT * FROM extensions $$,
    ROW('pair', 'theory', NOW(), NOW())::extensions,
    'And theory should still own "pair"'
);

-- Have theory record to other extensions.
SELECT ok(
    record_ownership('theory', ARRAY['foo', 'bar']),
    'Have theory own "foo" and "bar"'
);

SELECT is(COUNT(*)::int, 4, 'Should now have four extensions') FROM extensions;
SELECT is(COUNT(*)::int, 2, 'Should still have two co-owners') FROM coowners;

SELECT is(
    ARRAY(SELECT name FROM extensions WHERE owner = 'theory' ORDER BY name),
    ARRAY['bar', 'foo', 'pair']::citext[],
    'Theory should have ownership of three extensions'
);

/****************************************************************************/
-- Test add_distribution().
SELECT throws_ok(
    $_$ SELECT add_distribution('nobody', 'pshaw', $${
        "name":        "pair",
        "version":     "0.0.1",
        "license":     "postgresql",
        "maintainer":  "theory",
        "abstract":    "whatever"
    }$$) $_$,
    'P0001',
    'User “nobody” does not own all provided extensions',
    'Should get an exception for non-existent user'
);

DELETE FROM coowners;

SELECT throws_ok(
    $_$ SELECT add_distribution('theory', 'pshaw', $${
        "name":        "triple",
        "version":     "0.0.1",
        "license":     "postgresql",
        "maintainer":  "theory",
        "abstract":    "whatever"
    }$$) $_$,
    'P0001',
    'User “theory” does not own all provided extensions',
    'Should get an exception for user without permission'
);

DELETE FROM extensions;
-- Add a distribution.
SELECT bag_eq(
    $$ SELECT * FROM add_distribution('theory', 'pshaw', '{
        "name": "pair",
        "version": "0.0.01",
        "license": "postgresql",
        "maintainer": "theory",
        "abstract": "Ordered pair",
        "description": "An ordered pair for PostgreSQL",
        "tags": ["foo", "bar", "baz"],
        "no_index": null,
        "prereqs": {
          "runtime": {
            "requires": {
              "PostgreSQL": "8.0.0",
              "PostGIS": "1.5.0"
            },
            "recommends": {
              "PostgreSQL": "8.04.0"
            }
          }
        },
        "provides": {
            "pair": { "file": "pair.sql.in", "version": "0.02.02" },
            "trip": { "file": "trip.sql.in", "version": "0.02.01" }
        },
        "release_status": "testing",
        "resources": {
          "homepage": "http://pgxn.org/dist/pair/"
        }
    }')$$,
    $$VALUES ('meta', 'pair', '{
   "name": "pair",
   "abstract": "Ordered pair",
   "description": "An ordered pair for PostgreSQL",
   "version": "0.0.1",
   "maintainer": "theory",
   "release_status": "testing",
   "owner": "theory",
   "sha1": "pshaw",
   "license": "postgresql",
   "prereqs": {
      "runtime": {
         "recommends": {
            "PostgreSQL": "8.4.0"
         },
         "requires": {
            "PostGIS": "1.5.0",
            "PostgreSQL": "8.0.0"
         }
      }
   },
   "provides": {
      "pair": {
         "file": "pair.sql.in",
         "version": "0.2.2"
      },
      "trip": {
         "file": "trip.sql.in",
         "version": "0.2.1"
      }
   },
   "tags": ["foo", "bar", "baz"],
   "resources": {
      "homepage": "http://pgxn.org/dist/pair/"
   }
}
'),('by-owner', 'theory', '{
   "nickname": "theory",
   "name": "",
   "email": "theory@pgxn.org",
   "releases": {
      "pair": {
         "testing": ["0.0.1"]
      }
   }
}
')$$, 'Add a distribution for user "theory"');

SELECT is(COUNT(*)::int, 1, 'Should have one distribution') FROM distributions;
SELECT row_eq(
    $$ SELECT name, version, abstract, description, relstatus, owner, sha1, NULL::text, created_at FROM distributions $$,
    ROW('pair', '0.0.1', 'Ordered pair', 'An ordered pair for PostgreSQL', 'testing', 'theory', 'pshaw', NULL, NOW())::distributions,
    'It should look as expected'
);

SELECT is(meta, '{
   "name": "pair",
   "abstract": "Ordered pair",
   "description": "An ordered pair for PostgreSQL",
   "version": "0.0.1",
   "maintainer": "theory",
   "release_status": "testing",
   "owner": "theory",
   "sha1": "pshaw",
   "license": "postgresql",
   "prereqs": {
      "runtime": {
         "recommends": {
            "PostgreSQL": "8.4.0"
         },
         "requires": {
            "PostGIS": "1.5.0",
            "PostgreSQL": "8.0.0"
         }
      }
   },
   "provides": {
      "pair": {
         "file": "pair.sql.in",
         "version": "0.2.2"
      },
      "trip": {
         "file": "trip.sql.in",
         "version": "0.2.1"
      }
   },
   "tags": ["foo", "bar", "baz"],
   "resources": {
      "homepage": "http://pgxn.org/dist/pair/"
   }
}
', '...including the metadata')
  FROM distributions
 WHERE name = 'pair' AND version = '0.0.1';

SELECT is(COUNT(*)::int, 2, 'Should now have two extensions') FROM extensions;
SELECT bag_eq(
    $$ SELECT * FROM extensions ORDER BY name $$,
    $$ VALUES
       ('pair', 'theory', NOW(), NOW()),
       ('trip', 'theory', NOW(), NOW())
    $$,
    'We should have the expected extensions'
);

SELECT is(COUNT(*)::int, 2, 'Should now have two distribution extensions')
  FROM distribution_extensions;
SELECT bag_eq(
    $$ SELECT * FROM distribution_extensions $$,
    $$ VALUES
       ('pair', '0.2.2', 'pair', '0.0.1'),
       ('trip', '0.2.1', 'pair', '0.0.1')
    $$,
    'We should have the expected distribution extensions'
);

SELECT is(COUNT(*)::int, 3, 'Should now have three distribution tags')
  FROM distribution_tags;
SELECT is(
    ARRAY(
        SELECT tag
          FROM distribution_tags
         WHERE distribution = 'pair'
           AND VERSION = '0.0.1' ORDER BY tag
    ),
    ARRAY['bar'::citext, 'baz', 'foo'],
    'And they should be the expected tags'
);

SELECT throws_ok(
    $$ SELECT add_distribution('theory', 'foo', '{
        "name":        "pair",
        "version":     "0.0.1",
        "license":     "postgresql",
        "maintainer":  "theory",
        "abstract":    "whatever"
    }') $$,
    'P0001',
    'Distribution pair 0.0.1 already exists',
    'Should get an exception for a duplicate distribution and version'
);

-- Have strongrrl add a distribution with one extension.
SELECT bag_eq(
    $$SELECT * FROM add_distribution('strongrrl', 'ick', '{
        "name":        "foo",
        "version":     "0.0.2",
        "license":     "postgresql",
        "maintainer":  "strongrrl",
        "abstract":    "whatever",
        "tags": ["Foo", "PAIR", "pair"]
    }')$$,
    $$VALUES('meta', 'foo', '{
   "name": "foo",
   "abstract": "whatever",
   "version": "0.0.2",
   "maintainer": "strongrrl",
   "release_status": "stable",
   "owner": "strongrrl",
   "sha1": "ick",
   "license": "postgresql",
   "provides": {
      "foo": {
         "version": "0.0.2"
      }
   },
   "tags": ["Foo", "PAIR", "pair"]
}
'), ('by-owner', 'strongrrl', '{
   "nickname": "strongrrl",
   "name": "",
   "email": "strongrrl@pgxn.org",
   "releases": {
      "foo": {
         "stable": ["0.0.2"]
      }
   }
}
')$$, 'Should get proper JSON for strongrrl upload');

SELECT is(COUNT(*)::int, 2, 'Should now have two distributions') FROM distributions;
SELECT row_eq(
    $$ SELECT name, version, abstract, description, relstatus, owner, sha1, NULL::text, created_at FROM distributions WHERE owner = 'strongrrl' $$,
    ROW('foo', '0.0.2', 'whatever', '', 'stable', 'strongrrl', 'ick', NULL, NOW())::distributions,
    'The new one should look as expected'
);

SELECT is(meta, '{
   "name": "foo",
   "abstract": "whatever",
   "version": "0.0.2",
   "maintainer": "strongrrl",
   "release_status": "stable",
   "owner": "strongrrl",
   "sha1": "ick",
   "license": "postgresql",
   "provides": {
      "foo": {
         "version": "0.0.2"
      }
   },
   "tags": ["Foo", "PAIR", "pair"]
}
', '...including the metadata')
  FROM distributions
 WHERE name = 'foo' AND version = '0.0.2';

SELECT is(COUNT(*)::int, 3, 'Should now have three extensions') FROM extensions;
SELECT bag_eq(
    $$ SELECT * FROM extensions ORDER BY name $$,
    $$ VALUES
       ('pair', 'theory', NOW(), NOW()),
       ('trip', 'theory', NOW(), NOW()),
       ('foo', 'strongrrl', NOW(), NOW())
    $$,
    'We should have the expected extensions'
);

SELECT is(COUNT(*)::int, 3, 'Should now have three distribution extensions')
  FROM distribution_extensions;
SELECT bag_eq(
    $$ SELECT * FROM distribution_extensions $$,
    $$ VALUES
       ('pair', '0.2.2', 'pair', '0.0.1'),
       ('trip', '0.2.1', 'pair', '0.0.1'),
       ('foo', '0.0.2',  'foo',  '0.0.2')
    $$,
    'We should have the expected distribution extensions'
);

SELECT is(COUNT(*)::int, 5, 'Should now have five distribution tags')
  FROM distribution_tags;
SELECT is(
    ARRAY(
        SELECT tag
          FROM distribution_tags
         WHERE distribution = 'foo'
           AND VERSION = '0.0.2' ORDER BY tag
    ),
    ARRAY['foo'::citext, 'PAIR'],
    'And they should be the expected tags'
);

-- Strongrrl shouldn't be able to upload new pair.
SELECT throws_ok(
    $_$ SELECT add_distribution('strongrrl', 'howdy', $${
        "name":        "pair",
        "version":     "0.0.3",
        "license":     "postgresql",
        "maintainer":  "theory",
        "abstract":    "whatever"
    }$$) $_$,
    'P0001',
    'User “strongrrl” does not own all provided extensions',
    'Should get an exception for non-existent user'
);

-- Give strongrrl co-ownership of pair and try again.
INSERT INTO coowners (extension, nickname) VALUES ('pair', 'strongrrl');

SELECT bag_eq(
    $$ SELECT * FROM add_distribution('strongrrl', 'howdy', '{
        "name":        "pair",
        "version":     "0.0.3",
        "license":     "postgresql",
        "maintainer":  "theory",
        "abstract":    "whatever"
    }')$$,
    $$VALUES('meta', 'pair', '{
   "name": "pair",
   "abstract": "whatever",
   "version": "0.0.3",
   "maintainer": "theory",
   "release_status": "stable",
   "owner": "strongrrl",
   "sha1": "howdy",
   "license": "postgresql",
   "provides": {
      "pair": {
         "version": "0.0.3"
      }
   }
}
'), ('by-owner', 'strongrrl', '{
   "nickname": "strongrrl",
   "name": "",
   "email": "strongrrl@pgxn.org",
   "releases": {
      "foo": {
         "stable": ["0.0.2"]
      },
      "pair": {
         "stable": ["0.0.3"]
      }
   }
}
')$$, 'Should get proper JSON for strongrrl pair upload');

SELECT is(COUNT(*)::int, 3, 'Should now have three distributions') FROM distributions;
SELECT row_eq(
    $$ SELECT name, version, abstract, description, relstatus, owner, sha1, NULL::text, created_at FROM distributions WHERE owner = 'strongrrl' AND name = 'pair' $$,
    ROW('pair', '0.0.3', 'whatever', '', 'stable', 'strongrrl', 'howdy', NULL, NOW())::distributions,
    'The new one for strongrrl pair should look as expected'
);

SELECT is(meta, '{
   "name": "pair",
   "abstract": "whatever",
   "version": "0.0.3",
   "maintainer": "theory",
   "release_status": "stable",
   "owner": "strongrrl",
   "sha1": "howdy",
   "license": "postgresql",
   "provides": {
      "pair": {
         "version": "0.0.3"
      }
   }
}
', '...including the metadata')
  FROM distributions
 WHERE name = 'pair' AND version = '0.0.3';

SELECT is(COUNT(*)::int, 3, 'Should now have three extensions') FROM extensions;
SELECT bag_eq(
    $$ SELECT * FROM extensions ORDER BY name $$,
    $$ VALUES
       ('pair', 'theory', NOW(), NOW()),
       ('trip', 'theory', NOW(), NOW()),
       ('foo', 'strongrrl', NOW(), NOW())
    $$,
    'We should have the expected extensions'
);

SELECT is(COUNT(*)::int, 4, 'Should now have four distribution extensions')
  FROM distribution_extensions;
SELECT bag_eq(
    $$ SELECT * FROM distribution_extensions $$,
    $$ VALUES
       ('pair', '0.2.2', 'pair', '0.0.1'),
       ('trip', '0.2.1', 'pair', '0.0.1'),
       ('foo', '0.0.2',  'foo',  '0.0.2'),
       ('pair', '0.0.3', 'pair', '0.0.3')
    $$,
    'We should have the expected distribution extensions'
);

SELECT * FROM finish();
ROLLBACK;
