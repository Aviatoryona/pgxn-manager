SET search_path = public,contrib,tap;

BEGIN;
SELECT plan(226);
--SELECT * FROM no_plan();

-- Test the label data type.
SELECT has_type('label');
SELECT is( 'foo'::label, 'FOO'::label, 'labels should be case-insensitive' );
SELECT is( NULL::label, NULL, 'labels should be NULLable' );

SELECT lives_ok( 'SELECT ''foo''::label', '"foo" is a valid label' );
SELECT lives_ok( 'SELECT ''bar''::label', '"bar" is a valid label' );
SELECT lives_ok( 'SELECT ''FOO''::label', '"FOO" is a valid label' );
SELECT lives_ok( 'SELECT ''b1''::label', '"b1" is a valid label' );
SELECT lives_ok( 'SELECT ''b-a''::label', '"b-a" is a valid label' );
SELECT lives_ok( 'SELECT ''ba''::label', '"ba" is a valid label' );
SELECT lives_ok( 'SELECT ''a''::label', '"a" is a valid label' );
SELECT lives_ok( 'SELECT ''b-1a''::label', '"b-1a" is a valid label' );
SELECT lives_ok( 'SELECT ''b----a''::label', '"b----a" is a valid label' );

SELECT throws_ok(
    'SELECT ''2''::label',
    '23514',
    'value for domain label violates check constraint "label_check"',
    '"2" is not a valid label'
);
SELECT throws_ok(
    'SELECT ''b-''::label',
    '23514',
    'value for domain label violates check constraint "label_check"',
    '"b-" is not a valid label'
);
SELECT throws_ok(
    'SELECT ''-''::label',
    '23514',
    'value for domain label violates check constraint "label_check"',
    '"-" is not a valid label'
);
SELECT throws_ok(
    'SELECT ''f.b''::label',
    '23514',
    'value for domain label violates check constraint "label_check"',
    '"f.b" is not a valid label'
);
SELECT throws_ok(
    'SELECT ''f,b''::label',
    '23514',
    'value for domain label violates check constraint "label_check"',
    '"f,b" is not a valid label'
);
SELECT throws_ok(
    'SELECT ''Bj√∏rn''::label',
    '23514',
    'value for domain label violates check constraint "label_check"',
    'Non-ASCII characters invalid in labels'
);

-- Test the timezone data type.
SELECT is( NULL::timezone, NULL, 'time zones should be NULLable' );

SELECT lives_ok(
    'SELECT ''' || name || '''::timezone',
    name || ' should be a valid time zone'
)
  FROM (SELECT name FROM pg_timezone_names ORDER BY RANDOM() LIMIT 50) AS tz(name);

SELECT is(
       'Zulu'::timezone,
       'ZULU'::timezone,
       'TZs should be case-insensitive'
);

SELECT throws_ok(
    'SELECT ''FOO''::timezone',
    '23514',
    'value for domain timezone violates check constraint "timezone_check"',
     'Should die for invalid TZ "FOO"'
);
SELECT throws_ok(
    'SELECT ''BAR''::timezone',
    '23514',
    'value for domain timezone violates check constraint "timezone_check"',
     'Should die for invalid TZ "BAR"'
);
SELECT throws_ok(
    'SELECT ''America/Los_Angelos''::timezone',
    '23514',
    'value for domain timezone violates check constraint "timezone_check"',
     'Should die for invalid TZ "America/Los_Angelos"'
);

-- Test the email data type.
SELECT is( NULL::email, NULL, 'emails should be NULLable' );
SELECT lives_ok(
    'SELECT ''foo@bar.com''::email',
    '"foo@bar.com" should be a valid email'
);
SELECT lives_ok(
    'SELECT ''foo@bar.info''::email',
     '"foo@bar.info" should be a valid email'
);
SELECT throws_ok(
    'SELECT ''foo.info''::email',
    '23514',
    'value for domain email violates check constraint "email_check"',
     '"foo.info" should not be a valid email'
);
SELECT is(
    'foo@bar.com'::email,
     'FOO@BAR.COM'::email,
     'Emails should be case-insensitive'
);

-- Test the uri data type.
SELECT is( NULL::uri, NULL, 'URIs should be NULLable' );
SELECT lives_ok(
    'SELECT ''http://foo.com''::uri',
    'foo.com should be a valid HTTP URI'
);
SELECT lives_ok(
    'SELECT ''https://foo.com''::uri',
     'foo.com should be a valid HTTPS URI'
);
SELECT lives_ok(
    'SELECT ''http://foo.com/?id=1''::uri',
     'foo.com?id=1 should be a valid URI'
);
SELECT lives_ok(
    'SELECT ''http://w3.org/path%20with%20spaces.html''::uri',
    'URI with encoded spaces should be valid'
);
SELECT lives_ok(
    'SELECT ''http://192.168.0.1/''::uri',
    'An IP address URL is a valid URI'
);

SELECT lives_ok(
    'SELECT ''mailto:pgxn@kineticode.com''::uri',
    'A mailto: URL is a valid URI'
);

SELECT throws_ok(
    'SELECT ''''::uri',
    '23514',
    'value for domain uri violates check constraint "uri_check"',
    'An empty string is not a URI'
);
SELECT throws_ok(
    'SELECT ''hey me://foo.com''::uri',
    '23514',
    'value for domain uri violates check constraint "uri_check"',
    'A URI witn an invalid scheme should not be valid'
);
SELECT throws_ok(
    'SELECT ''http://w3.org/path with spaces.html''::uri',
    '23514',
    'value for domain uri violates check constraint "uri_check"',
    'URI with unencoded spaces should not be valid'
);

-- Test the semver data type.
SELECT has_type('semver');
SELECT is( NULL::semver, NULL, 'semvers should be NULLable' );

SELECT lives_ok(
    $$ SELECT '$$ || v || $$'::semver $$,
    '"' || v || '" is a valid semver'
)  FROM unnest(ARRAY[
    '1.2.2',
    '0.2.2',
    '1.2.2',
    '0.0.0',
    '0.1.999',
    '9999.9999999.823823',
    '1.0.0beta1',
    '1.0.0beta2',
    '1.0.0',
    '999999999999999333333.0.0'
]) AS v;

SELECT throws_ok(
    $$ SELECT '$$ || v || $$'::semver $$,
    NULL,
    '"' || v || '" is not a valid semver'
)  FROM unnest(ARRAY[
   '1.2',
   '1.2.02',
   '1.2.2-',
   '1.2.3b#5',
   '03.3.3',
   'v1.2.2',
   '1.3b',
   '1.4b.0',
   '1v',
   '1v.2.2v',
   '1.2.4b.5'
]) AS v;

-- Test =, <=, and >=.
SELECT collect_tap(
    ok(semver_cmp(lv, rv) = 0, 'semver(' || lv || ', ' || rv || ') should = 0'),
    ok(lv::semver = rv::semver, 'v' || lv || ' should = v' || rv),
    ok(lv::semver <= rv::semver, 'v' || lv || ' should be <= v' || rv),
    ok(lv::semver >= rv::semver, 'v' || lv || ' should be >= v' || rv)
) FROM (VALUES
    ('1.2.2',  '1.2.2'),
    ('1.2.23', '1.2.23'),
    ('0.0.0', '0.0.0'),
    ('999.888.7777', '999.888.7777'),
    ('0.1.2beta3', '0.1.2beta3'),
    ('1.0.0rc-1', '1.0.0RC-1')
 ) AS f(lv, rv);

-- Test semver <> semver
SELECT collect_tap(
    ok(semver_cmp(lv, rv) <> 0, 'semver(' || lv || ', ' || rv || ') should <> 0'),
    ok(lv::semver <> rv::semver, 'v' || lv || ' should not equal v' || rv)
) FROM (VALUES
    ('1.2.2', '1.2.3'),
    ('0.0.1', '1.0.0'),
    ('1.0.1', '1.1.0'),
    ('1.1.1', '1.1.0'),
    ('1.2.3b', '1.2.3'),
    ('1.2.3', '1.2.3b'),
    ('1.2.3a', '1.2.3b'),
    ('1.2.3aaaaaaa1', '1.2.3aaaaaaa2')
  ) AS f(lv, rv);

-- Test >, >=, <, and <=.
SELECT collect_tap(
    ok( semver_cmp(lv, rv) > 0, 'semver(' || lv || ', ' || rv || ') should > 0'),
    ok( semver_cmp(rv, lv) < 0, 'semver(' || rv || ', ' || lv || ') should < 0'),
    ok(lv::semver > rv::semver, 'v' || lv || ' should be > v' || rv),
    ok(lv::semver >= rv::semver, 'v' || lv || ' should be >= v' || rv),
    ok(rv::semver < lv::semver, 'v' || rv || ' should be < v' || lv),
    ok(rv::semver <= lv::semver, 'v' || rv || ' should be <= v' || lv)
) FROM (VALUES
    ('2.2.2', '1.1.1'),
    ('2.2.2', '2.1.1'),
    ('2.2.2', '2.2.1'),
    ('2.2.2b', '2.2.1'),
    ('2.2.2', '2.2.2b'),
    ('2.2.2c', '2.2.2b'),
    ('2.2.2rc-2', '2.2.2RC-1'),
    ('0.9.10', '0.9.9')
  ) AS f(lv, rv);

-- Test clean_semver().
SELECT has_function('clean_semver');
SELECT has_function('clean_semver', ARRAY['text']);
SELECT function_returns('clean_semver', 'semver');

SELECT is(
    clean_semver(dirty),
    clean::semver,
    'clean_semver(' || dirty || ') should return ' || clean
) FROM (VALUES
    ('1.2.2',          '1.2.2'),
    ('01.2.2',         '1.2.2'),
    ('1.02.2',         '1.2.2'),
    ('1.2.02',         '1.2.2'),
    ('1.2.02b',        '1.2.2b'),
    ('1.2.02beta-3  ', '1.2.2beta-3'),
    ('1.02.02rc1',     '1.2.2rc1'),
    ('1.0',            '1.0.0'),
    ('.0.02',          '0.0.2'),
    ('1..02',          '1.0.2'),
    ('1..',            '1.0.0'),
    ('1.1',            '1.1.0'),
    ('1.2.b1',         '1.2.0b1'),
    ('9.0beta4',       '9.0.0beta4'), -- PostgreSQL format.
    ('9b',             '9.0.0b'),
    ('rc1',            '0.0.0rc1'),
    ('',               '0.0.0'),
    ('..2',            '0.0.2'),
    ('  012.2.2',      '12.2.2'),
    ('9999999999988',  '9999999999988.0.0')
) v(dirty, clean);

-- Test sort ordering
CREATE TABLE vs (
    version semver
);

INSERT INTO vs VALUES ('1.2.0'), ('1.0.0'), ('0.9.9'), ('0.9.10');

SELECT is(max(version), '1.2.0', 'max(semver) should work')
  FROM vs;

SELECT is(min(version), '0.9.9', 'min(semver) should work')
  FROM vs;

SELECT results_eq(
    $$ SELECT version FROM vs ORDER BY version USING < $$,
    $$ VALUES ('0.9.9'::semver), ('0.9.10'::semver), ('1.0.0'::semver), ('1.2.0'::semver) $$,
    'ORDER BY semver USING < should work'
);

SELECT results_eq(
    $$ SELECT version FROM vs ORDER BY version USING > $$,
    $$ VALUES ('1.2.0'::semver), ('1.0.0'::semver), ('0.9.10'::semver), ('0.9.9'::semver) $$,
    'ORDER BY semver USING > should work'
);

SELECT * FROM finish();
ROLLBACK;